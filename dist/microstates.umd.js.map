{"version":3,"file":"microstates.umd.js","sources":["../rollupPluginBabelHelpers","../src/monad.js","../src/utils/chain.js","../src/thunk.js","../src/utils/tree.js","../src/lens.js","../src/utils/get-prototype-descriptors.js","../src/types/string.js","../src/types/number.js","../src/types/boolean.js","../src/utils/secret.js","../src/types/parameters0.js","../src/types/array.js","../src/types/object.js","../src/types/parameters.js","../src/types.js","../src/utils/is-primitive.js","../src/utils/transitions-for.js","../src/is-simple.js","../src/typeclasses/values.js","../src/desugar.js","../src/typeclasses/collapse.js","../src/structure.js","../src/microstate.js","../src/typeclasses.js","../src/index.js"],"sourcesContent":["export { _typeof as typeof, _jsx as jsx, _asyncIterator as asyncIterator, _AwaitValue as AwaitValue, _AsyncGenerator as AsyncGenerator, _wrapAsyncGenerator as wrapAsyncGenerator, _awaitAsyncGenerator as awaitAsyncGenerator, _asyncGeneratorDelegate as asyncGeneratorDelegate, _asyncToGenerator as asyncToGenerator, _classCallCheck as classCallCheck, _createClass as createClass, _defineEnumerableProperties as defineEnumerableProperties, _defaults as defaults, _defineProperty as defineProperty, _extends as extends, _get as get, _inherits as inherits, _inheritsLoose as inheritsLoose, _wrapNativeSuper as wrapNativeSuper, _instanceof as instanceof, _interopRequireDefault as interopRequireDefault, _interopRequireWildcard as interopRequireWildcard, _newArrowCheck as newArrowCheck, _objectDestructuringEmpty as objectDestructuringEmpty, _objectWithoutProperties as objectWithoutProperties, _assertThisInitialized as assertThisInitialized, _possibleConstructorReturn as possibleConstructorReturn, _set as set, _slicedToArray as slicedToArray, _slicedToArrayLoose as slicedToArrayLoose, _taggedTemplateLiteral as taggedTemplateLiteral, _taggedTemplateLiteralLoose as taggedTemplateLiteralLoose, _temporalRef as temporalRef, _readOnlyError as readOnlyError, _classNameTDZError as classNameTDZError, _temporalUndefined as temporalUndefined, _toArray as toArray, _toConsumableArray as toConsumableArray, _skipFirstGeneratorNext as skipFirstGeneratorNext, _toPropertyKey as toPropertyKey, _initializerWarningHelper as initializerWarningHelper, _initializerDefineProperty as initializerDefineProperty, _applyDecoratedDescriptor as applyDecoratedDescriptor };\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar REACT_ELEMENT_TYPE;\n\nfunction _jsx(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  }\n\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n\n  if (!props && childrenLength !== 0) {\n    props = {\n      children: void 0\n    };\n  }\n\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n\n    props.children = childArray;\n  }\n\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : '' + key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n}\n\nfunction _asyncIterator(iterable) {\n  if (typeof Symbol === \"function\") {\n    if (Symbol.asyncIterator) {\n      var method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      return iterable[Symbol.iterator]();\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(\"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  if (typeof Symbol === \"function\" && Symbol.iterator) {\n    iter[Symbol.iterator] = function () {\n      return this;\n    };\n  }\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner.throw === \"function\") {\n    iter.throw = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner.return === \"function\") {\n    iter.return = function (value) {\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          Promise.resolve(value).then(_next, _throw);\n        }\n      }\n\n      function _next(value) {\n        step(\"next\", value);\n      }\n\n      function _throw(err) {\n        step(\"throw\", err);\n      }\n\n      _next();\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return _get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _gPO = Object.getPrototypeOf || function _gPO(o) {\n  return o.__proto__;\n};\n\nvar _sPO = Object.setPrototypeOf || function _sPO(o, p) {\n  o.__proto__ = p;\n  return o;\n};\n\nvar _construct = typeof Reflect === \"object\" && Reflect.construct || function _construct(Parent, args, Class) {\n  var Constructor,\n      a = [null];\n  a.push.apply(a, args);\n  Constructor = Parent.bind.apply(Parent, a);\n  return _sPO(new Constructor(), Class.prototype);\n};\n\nvar _cache = typeof Map === \"function\" && new Map();\n\nfunction _wrapNativeSuper(Class) {\n  if (typeof Class !== \"function\") {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  if (typeof _cache !== \"undefined\") {\n    if (_cache.has(Class)) return _cache.get(Class);\n\n    _cache.set(Class, Wrapper);\n  }\n\n  function Wrapper() {}\n\n  Wrapper.prototype = Object.create(Class.prototype, {\n    constructor: {\n      value: Wrapper,\n      enumerable: false,\n      writeable: true,\n      configurable: true\n    }\n  });\n  return _sPO(Wrapper, _sPO(function Super() {\n    return _construct(Class, arguments, _gPO(this).constructor);\n  }, Class));\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n}\n\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      _set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n}\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _slicedToArrayLoose(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _temporalRef(val, name) {\n  if (val === _temporalUndefined) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n}\n\nfunction _readOnlyError(name) {\n  throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n}\n\nfunction _classNameTDZError(name) {\n  throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n}\n\nvar _temporalUndefined = {};\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _skipFirstGeneratorNext(fn) {\n  return function () {\n    var it = fn.apply(this, arguments);\n    it.next();\n    return it;\n  };\n}\n\nfunction _toPropertyKey(key) {\n  if (typeof key === \"symbol\") {\n    return key;\n  } else {\n    return String(key);\n  }\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');\n}\n\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}","import { Applicative, type } from 'funcadelic';\n\nexport const Monad = type(\n  class Monad extends Applicative {\n    flatMap(fn, m) {\n      return this(m).flatMap(fn, m);\n    }\n  }\n);\n\nexport const { flatMap } = Monad.prototype;\n","import { map, filter, append } from 'funcadelic';\nimport { flatMap } from '../monad';\n\nclass Chain {\n  constructor(value) {\n    Object.defineProperty(this, 'valueOf', {\n      value() {\n        return value;\n      },\n    });\n  }\n\n  map(fn) {\n    return new Chain(map(fn, this.valueOf()));\n  }\n\n  flatMap(fn) {\n    return new Chain(flatMap(fn, this.valueOf()));\n  }\n  \n  filter(fn) {\n    return new Chain(filter(fn, this.valueOf()));\n  }\n\n  append(thing) {\n    return new Chain(append(this.valueOf(), thing));\n  }\n\n  tap(fn) {\n    fn(this.valueOf());\n    return this;\n  }\n}\n\nexport default function chain(value) {\n  return new Chain(value);\n}\n","export default function thunk(fn) {\n  let evaluated = false;\n  let result = undefined;\n  return function evaluate() {\n    if (evaluated) {\n      return result;\n    } else {\n      result = fn.call(this);\n      evaluated = true;\n      return result;\n    }\n  };\n}\n","import { append, filter, map } from 'funcadelic';\nimport $ from './chain';\nimport thunk from '../thunk';\nimport getOwnPropertyDescriptors from 'object.getownpropertydescriptors';\n\nlet { keys } = Object;\n\nexport default class Tree {\n  constructor(props = {}) {\n    let { data = () => ({}), children = () => ({}) } = props;\n    return Object.create(Tree.prototype, {\n      data: {\n        get: thunk(data),\n        enumerable: true,\n      },\n      children: {\n        get: thunk(children),\n        enumerable: true,\n      },\n    });\n  }\n}\n\n/**\n * Turn any structure tree into a root tree.\n *\n * Every node in a tree knows its path. This path is what identifies\n * its context in the containing tree.\n *\n * This lets you take any tree, sitting at any context and make it\n * \"context free\". I.e. converts it into a root.\n *\n * @param {Tree} tree - the tree to isolate\n * @returns {Tree} - a tree just like `tree`, but now a root.\n */\nexport function prune(tree) {\n  let prefix = tree.data.path;\n  return map(node => append(node, { path: node.path.slice(prefix.length)}), tree);\n}\n\n/**\n * Change the path of a tree.\n *\n * This lets you take any tree, sitting at any context and prefix the context with\n * additional path.\n *\n * @param {*} tree\n * @param {*} path\n */\nexport function graft(path, tree) {\n  if (path.length === 0) {\n    return tree;\n  } else {\n    return map(node => append(node, { path: [...path, ...node.path]}), tree);\n  }\n}\n","export { default as lens } from 'ramda/src/lens';\nexport { default as view } from 'ramda/src/view';\nexport { default as set } from 'ramda/src/set';\nexport { default as lensPath } from 'ramda/src/lensPath';\nexport { default as lensIndex } from 'ramda/src/lensIndex';\nexport { default as compose } from 'ramda/src/compose';\n\nimport lens from 'ramda/src/lens';\nimport view from 'ramda/src/view';\nimport Tree from './utils/tree';\nimport { map, foldl } from 'funcadelic';\n\nexport function lensTree(path = []) {\n  function get(tree) {\n    return foldl((subtree, key) => subtree.children[key], tree, path);\n  }\n\n  function set(newTree, tree, current = path) {\n    if (current.length === 0) {\n      return newTree;\n    } else {\n      return new Tree({\n        data: () => tree.data,\n        children: () =>\n          map((child, childName) => {\n            let [key, ...rest] = current;\n            if (key === childName) {\n              return set(newTree, child, rest);\n            } else {\n              return child;\n            }\n          }, tree.children),\n      });\n    }\n  }\n  return lens(get, set);\n}\n","import { append } from 'funcadelic';\nimport getOwnPropertyDescriptors from 'object.getownpropertydescriptors';\n\nconst { getPrototypeOf, create } = Object;\n\nexport default function getPrototypeDescriptors(Class) {\n  let prototype = getPrototypeOf(Class);\n  if (prototype && prototype !== getPrototypeOf(Object)) {\n    return append(getPrototypeDescriptors(prototype), getOwnPropertyDescriptors(Class.prototype));\n  } else {\n    return getOwnPropertyDescriptors(Class.prototype);\n  }\n}\n","export default class StringType {\n  constructor(value = '') {\n    return new String(value);\n  }\n  concat(...args) {\n    return String.prototype.concat.apply(this.state, args);\n  }\n}\n","export default class NumberType {\n  constructor(value = 0) {\n    return new Number(value);\n  }\n  sum(...args) {\n    return args.reduce((accumulator, value) => accumulator + value, this.state);\n  }\n  subtract(...args) {\n    return args.reduce((accumulator, value) => accumulator - value, this.state);\n  }\n  increment(step = 1) {\n    return this.state + step;\n  }\n  decrement(step = 1) {\n    return this.state - step;\n  }\n}\n","export default class BooleanType {\n  constructor(value = false) {\n    return new Boolean(value);\n  }\n  toggle() {\n    return !this.state;\n  }\n}\n","const symbol = Symbol('🙈');\n\nconst { getOwnPropertySymbols } = Object;\n\nexport function keep(object, value) {\n  return Object.defineProperty(object, symbol, {\n    value,\n    enumerable: false,\n  });\n}\n\nexport function reveal(object) {\n  if (object && getOwnPropertySymbols(object).includes(symbol)) {\n    return object[symbol];\n  }\n}\n","import { foldl, append } from 'funcadelic';\n\nconst TYPE_PARAMETERS = Symbol('Type Parameters');\n\nexport function parameterized(Type, ...substitutions) {\n  let defaults = params(Type);\n  let keys = Object.keys(defaults);\n  let parameters = foldl((parameters, param, index) => {\n    if (typeof param === 'function') {\n      let key = keys[index];\n      if (key) {\n        return append(parameters, {[key]: param});\n      } else {\n        return parameters;\n      }\n    } else {\n      return append(parameters, param);\n    }\n  }, defaults, substitutions);\n\n  return class Parameterized extends Type {\n    static get name() { return Type.name; }\n    static get toString() {\n      let names = Object.keys(parameters).map(k => {\n        let parameter = parameters[k];\n        if (Object.keys(params(parameter)).length) {\n          return parameter.toString();\n        }\n        if (parameter.name != null) {\n          return parameter.name;\n        } else {\n          return parameter.toString();\n        }\n      });\n      return () => `${Type.name}<${names.join(',')}>`;\n    }\n    static get [TYPE_PARAMETERS]() { return parameters; };\n  };\n}\n\nexport function params(Constructor) {\n  return Constructor[TYPE_PARAMETERS] || {};\n}\n\nexport const any = 'any';\n","import { append, foldl, map } from 'funcadelic';\nimport set from 'ramda/src/set';\nimport indexOf from 'ramda/src/indexOf';\nimport lensPath from 'ramda/src/lensPath';\nimport $ from '../utils/chain';\nimport { reveal } from '../utils/secret';\nimport Tree, { prune, graft } from '../utils/tree';\nimport { parameterized, params, any } from './parameters0';\n\nclass ArrayType {\n  constructor(value = []) {\n    return value instanceof Array ? value : [value];\n  }\n  push(item) {\n    return this.splice(this.state.length, 0, [item]);\n  }\n  pop() {\n    return this.splice(this.state.length - 1, 1, []);\n  }\n  shift() {\n    return this.splice(0, 1, []);\n  }\n  unshift(item) {\n    return this.splice(0, 0, [item]);\n  }\n  filter(fn) {\n    return foldl(({array, removed}, state, i) => {\n      if (fn(state)) {\n        return { array, removed };\n      } else {\n        return {\n          array: array.splice(i - removed, 1, []),\n          removed: removed + 1\n        };\n      }\n    }, {array: this, removed: 0}, this.state).array;\n  }\n  map(callback) {\n    return Array.prototype.map.call(this.state, callback);\n  }\n\n  splice(startIndex, length, values) {\n    let Microstate = this.constructor;\n    let { create } = Microstate;\n    let { tree } = reveal(this);\n    let value = (this.valueOf() || []).slice();\n    value.splice(startIndex, length, ...values);\n\n    let { T } = params(tree.data.Type);\n    if (T === any) {\n      return value;\n    }\n\n    let unchanged = tree.children.slice(0, startIndex);\n\n    let added = $(values)\n        .map(value => create(T, value))\n        .map(reveal)\n        .map(({ tree }) => tree)\n        .valueOf();\n\n    let moved = map(prune, tree.children.slice(startIndex + length));\n\n    function attach(index, tree) {\n      return graft(append(tree.data.path, index), tree);\n    }\n\n    let children = $(unchanged)\n        .append(map((child, i) => attach(i + unchanged.length, child), added))\n        .append(map((child, i) => attach(i + unchanged.length + added.length, child), moved))\n        .valueOf();\n\n    let structure = new Tree({\n      data: () => tree.data,\n      children: () => children\n    });\n\n\n    return new Microstate(structure, value);\n  }\n  /**\n   * Return a new array with first occurance of found item\n   * replaced with the replacement. It is very optimistic and\n   * will not throw even when item is not found.\n   *\n   * ```js\n   * let ms = microstate(MS.Array, ['a', 'b', 'c']);\n   * // => [ d, b, c ]\n   * ```\n   * @param {any} item\n   * @param {any} replacement\n   */\n  replace(item, replacement) {\n    let index = indexOf(item, this.state);\n    if (index === -1) {\n      return this.state;\n    } else {\n      return set(lensPath([index]), replacement, this.state);\n    }\n  }\n}\n\nexport default parameterized(ArrayType, {T: any});\n","import { parameterized, any } from './parameters0';\n\nclass ObjectType {\n  constructor(value = {}) {\n    return new Object(value);\n  }\n  assign(props) {\n    return Object.assign({}, this.state, props);\n  }\n}\n\nexport default parameterized(ObjectType, {T: any});\n","import { map } from 'funcadelic';\nimport { parameterized as parameterized0, params as params0 } from './parameters0';\nimport { toType } from '../types';\n\nexport function parameterized(Constructor, ...rest) {\n  let Type = toType(Constructor, ...rest);\n  return parameterized0(Type, ...map(item => typeof item === 'function' ? toType(item) : map(toType, item), rest));\n}\n\nexport function params(Constructor) {\n  return params0(toType(Constructor));\n}\n\nexport { any } from './parameters0';\n","import StringType from './types/string';\nimport NumberType from './types/number';\nimport BooleanType from './types/boolean';\nimport ArrayType from './types/array';\nimport ObjectType from './types/object';\n\nexport default {\n  String: StringType,\n  Number: NumberType,\n  Boolean: BooleanType,\n  Array: ArrayType,\n  Object: ObjectType\n};\n\nexport function toType(Constructor) {\n  switch (Constructor) {\n  case Array:\n    return ArrayType;\n  case Object:\n    return ObjectType;\n  case Number:\n    return NumberType;\n  case String:\n    return StringType;\n  case Boolean:\n    return BooleanType;\n  default:\n    return Constructor;\n  }\n}\n\nexport { parameterized, params, any } from './types/parameters';\n","const { keys } = Object;\n\nexport default function isPrimitive(Type) {\n  return keys(new Type()).length === 0;\n}\n","import { append } from 'funcadelic';\nimport $ from './chain';\nimport mergeDeepRight from 'ramda/src/mergeDeepRight';\nimport getPrototypeDescriptors from './get-prototype-descriptors';\nimport Microstate from '../microstate';\nimport { toType } from '../types';\n\nimport isPrimitive from './is-primitive';\n\nfunction setTransition(value) {\n  return value;\n};\n\nfunction mergeTransition(...args) {\n  return mergeDeepRight(this.state, ...args);\n};\n\nexport default function transitionsFor(Type) {\n  let descriptors = getPrototypeDescriptors(toType(Type));\n\n  let transitionFns = $(descriptors)\n    .filter(({ value }) => isFunctionDescriptor(value))\n    .map(({ value }) => value)\n    .filter(({ key }) => key !== 'constructor')\n    .valueOf();\n\n  let common = isPrimitive(Type) ? { set: setTransition } : { set: setTransition, merge: mergeTransition };\n  return append(common, transitionFns);\n}\n\nfunction isFunctionDescriptor(descriptor) {\n  return typeof descriptor.value === 'function';\n}\n","import StringType from './types/string';\nimport BooleanType from './types/boolean';\nimport NumberType from './types/number';\nimport ObjectType from './types/object';\nimport ArrayType from './types/array';\n\nimport { toType } from './types';\nimport { params, any } from './types/parameters';\n\nexport default function isSimple(Constructor) {\n  let Type = toType(Constructor);\n  if (Type === BooleanType) {\n    return true;\n  }\n  if (Type === NumberType) {\n    return true;\n  }\n  if (Type === StringType) {\n    return true;\n  }\n  if (Type === ArrayType || Type.prototype instanceof ArrayType) {\n    let { T } = params(Type);\n    return isSimple(T);\n  }\n  if (Type === ObjectType || Type.prototype instanceof ObjectType) {\n    let { T } = params(Type);\n    if (T === any) {\n      return true;\n    } else {\n      return isSimple(T);\n    }\n  }\n  if (Type === any) {\n    return true;\n  }\n  return false;\n}\n","import { type, map } from 'funcadelic';\n\nconst { keys } = Object;\n\nconst Values = type(class Values {\n  values(holder) {\n    return this(holder).values(holder);\n  }\n})\n\nValues.instance(Array, {\n  values(array) { return array; }\n});\n\nValues.instance(Object, {\n  values(object) { return map(key => object[key], keys(object)); }\n});\n\nexport const { values } = Values.prototype;","import { Monoid } from 'funcadelic';\nimport { parameterized } from '../src/types';\nimport { values } from './typeclasses/values';\nimport { map } from 'funcadelic';\n\nexport const ContainsTypes = Monoid.create(class ContainsTypes {\n  empty() { return true; }\n  append(a, b) {\n    return a && (b instanceof Function || isSugar(b));\n  }\n});\n\nexport function isPossibleSugar(Type) {\n  return Type && (Type.constructor === Array || Type.constructor === Object);\n}\n\nexport function isSugar(Type) {\n  return isPossibleSugar(Type) && ContainsTypes.reduce(values(Type));\n}\n\nexport default function desugar(Type) {\n  if (isSugar(Type)) {\n    let { constructor: c } = Type;\n    if (c === Array) {\n      return parameterized(Array, ...map(desugar, values(Type)));\n    }\n    if (c === Object) {\n      return parameterized(Object, ...map(desugar, values(Type)));\n    }\n  }\n  return Type;\n}","import { type } from 'funcadelic';\n\nexport const Collapse = type(class Collapse {\n  collapse(holder) {\n    return this(holder).collapse(holder);\n  }\n});\n\nexport const { collapse } = Collapse.prototype;","import $ from './utils/chain';\nimport { type, map, append, pure } from 'funcadelic';\nimport { flatMap } from './monad';\nimport { view, set, lensTree, lensPath } from './lens';\nimport Tree, { graft, prune } from './utils/tree';\nimport transitionsFor from './utils/transitions-for';\nimport { reveal } from './utils/secret';\nimport types, { params, any, toType } from './types';\nimport isSimple  from './is-simple';\nimport desugar from './desugar';\nimport Microstate from './microstate';\nimport { collapse } from './typeclasses/collapse';\nimport getPrototypeDescriptors from './utils/get-prototype-descriptors';\nimport thunk from './thunk';\n\nconst { assign } = Object;\n\nexport default function analyze(Type, value) {\n  return flatMap(analyzeType(value), pure(Tree, new Node(Type, [])));\n}\n\nexport function collapseState(tree, value) {\n  let truncated = truncate(node => node.isSimple, tree);\n  return collapse(map(node => node.stateAt(value), truncated));\n}\n\nfunction analyzeType(value) {\n  return (node) => {\n    let InitialType = desugar(node.Type);\n    let valueAt = node.valueAt(value);\n    let Type = toType(InitialType);\n\n    let instance = Type.hasOwnProperty('create') ? Type.create(valueAt) : undefined;\n\n    if (instance instanceof Microstate) {\n      let { tree , value } = reveal(instance);\n\n      let shift = new ShiftNode(tree.data, value);\n      return graft(node.path, new Tree({\n        data: () => shift,\n        children: () => tree.children\n      }));\n    }\n\n    return new Tree({\n      data: () => Type === node.Type ? node : append(node, { Type }),\n      children() {\n        let childTypes = childrenAt(Type, node.valueAt(value));\n        return map((ChildType, path) => pure(Tree, new Node(ChildType, append(node.path, path))), childTypes);\n      }\n    });\n  };\n}\n\nconst Location = type(class Location {\n  stateAt(Type, instance, value) {\n    return this(Type.prototype).stateAt(instance, value);\n  }\n  childrenAt(Type, value) {\n    return this(Type.prototype).childrenAt(Type, value);\n  }\n});\n\nconst { stateAt, childrenAt } = Location.prototype;\n\nLocation.instance(Object, {\n  stateAt(instance, value) {\n    if (value) {\n      return append(instance, value);\n    } else {\n      return instance;\n    }\n  },\n\n  childrenAt(Type, value) {\n    return $(new Type())\n      .map(desugar)\n      .filter(({ value }) => !!value && value.call)\n      .valueOf();\n  }\n});\n\nLocation.instance(types.Object, {\n  stateAt: _ => {},\n  childrenAt(Type, value) {\n    let { T } = params(Type);\n    if (T !== any) {\n      return map(_ => T, value);\n    } else {\n      return Location.for(Object).childrenAt(Type, value);\n    }\n  }\n});\n\nLocation.instance(types.Array, {\n  stateAt: _ => [],\n  childrenAt(...args) {\n    return Location.for(types.Object.prototype).childrenAt(...args);\n  }\n});\n\nfunction truncate(fn, tree) {\n  return flatMap(node => {\n    let subtree = view(lensTree(node.path), tree);\n    if (fn(subtree.data)) {\n      return append(subtree, { children: [] });\n    } else {\n      return subtree;\n    }\n  }, tree);\n}\n\nfunction cachedGetters(Type) {\n  let descriptors = $(getPrototypeDescriptors(Type))\n    .filter(({ value }) => !!value.get)\n    .map(descriptor => append(descriptor, {\n      get: thunk(descriptor.get)\n    }))\n    .valueOf();\n  return Object.create(Type.prototype, descriptors);\n}\n\nclass Node {\n  constructor(Type, path) {\n    assign(this, { Type, path });\n  }\n\n  get isSimple() {\n    return isSimple(this.Type);\n  }\n\n  valueAt(total) {\n    return view(lensPath(this.path), total);\n  }\n\n  stateAt(value) {\n    let { Type } = this;\n    let valueAt = this.valueAt(value);\n    let instance = new Type(valueAt).valueOf();\n    if (isSimple(Type)) {\n      return valueAt || instance;\n    } else {\n      return stateAt(Type, append(instance, cachedGetters(Type)), valueAt);\n    }\n  }\n\n  transitionsAt(value, tree, invoke) {\n    let { Type, path } = this;\n\n    return map(method => (...args) => {\n      let localValue = this.valueAt(value);\n      let localTree = view(lensTree(path), tree);\n\n      let transition = {\n        method,\n        args,\n        value: localValue,\n        tree: prune(localTree)\n      };\n\n      let {\n        value: nextLocalValue,\n        tree: nextLocalTree\n      } = invoke(transition);\n\n      let nextTree = set(lensTree(path), graft(path, nextLocalTree), tree);\n      let nextValue = set(lensPath(path), nextLocalValue, value);\n\n      return { tree: nextTree, value: nextValue };\n    }, transitionsFor(Type));\n  }\n}\n\nclass ShiftNode extends Node {\n  constructor({ Type, path }, value) {\n    super(Type, path);\n    assign(this, { value });\n  }\n\n  valueAt() {\n    return this.value;\n  }\n}\n","import { map, append } from \"funcadelic\";\nimport analyze, { collapseState } from \"./structure\";\nimport { keep, reveal } from \"./utils/secret\";\nimport SymbolObservable from \"symbol-observable\";\nimport thunk from './thunk';\n\nexport default class Microstate {\n  constructor(tree, value) {\n\n    keep(this, { tree, value });\n    \n    return append(map(transition => transition, this), {\n      get state() {\n        return collapseState(tree, value);\n      }\n    });\n  }\n\n  /**\n   * Returns a new Microstate instance. A microstate is an object that\n   * wraps a type and a value and provides chainable transitions for\n   * this value.\n   *\n   * @param {*} Type\n   * @param {*} value\n   */\n  static create(Type, value) {\n    value = value != null ? value.valueOf() : value;\n    let tree = analyze(Type, value);\n    \n    return new Microstate(tree, value);\n  }\n\n  /**\n   * Return boxed in value for this microstates\n   */\n  valueOf() {\n    let { value } = reveal(this);\n    return value;\n  }\n\n  [SymbolObservable]() {\n    let microstate = this;\n    return {\n      subscribe(observer) {\n        let next = observer.call ? observer : observer.next.bind(observer);\n\n        function nextOnTransition(transition) {\n          return function invoke(...args) {\n            let nextable = map(nextOnTransition, transition(...args));\n            next(nextable);\n            return nextable;\n          };\n        }\n\n        next(map(nextOnTransition, microstate));\n      },\n      [SymbolObservable]() {\n        return this;\n      }\n    };\n  }\n}\n","import { Applicative, Functor, map, append } from 'funcadelic';\nimport { Monad, flatMap } from './monad';\nimport Microstate from './microstate';\nimport { reveal } from './utils/secret';\nimport Tree from './utils/tree';\nimport { Collapse, collapse } from './typeclasses/collapse';\nimport thunk from './thunk';\n\nconst { keys } = Object;\n\nfunction invoke({ method, args, value, tree}) {\n  let nextValue = method.apply(new Microstate(tree, value), args);\n  if (nextValue instanceof Microstate) {\n    return reveal(nextValue);\n  } else {\n    return { tree, value: nextValue };\n  }\n}\n\nFunctor.instance(Microstate, {\n  map(fn, microstate) {\n    let { tree, value } = reveal(microstate);\n\n    // tree of transitions\n    let next = map(node => {\n      let transitions = node.transitionsAt(value, tree, invoke);\n      return map(transition => {\n        return (...args) => {\n          let { tree, value } = transition(...args);\n          return new Microstate(tree, value);\n        };\n      }, transitions);\n    }, tree);\n\n    let mapped = map(transitions => map(fn, transitions), next);\n\n    return append(microstate, collapse(mapped));\n  }\n});\n\nCollapse.instance(Tree, {\n  collapse(tree) {\n    let hasChildren = !!keys(tree.children).length;\n    if (hasChildren) {\n      return append(tree.data, map(child => collapse(child), tree.children));\n    } else {\n      return tree.data;\n    }\n  }\n})\n\nFunctor.instance(Tree, {\n  /**\n   * Lazily invoke callback on every property of given tree,\n   * the return value is assigned to property value.\n   *\n   * @param {*} fn (TypeTree, path) => any\n   * @param {*} tree Tree\n   */\n  map(fn, tree) {\n    return new Tree({\n      data() {\n        return fn(tree.data);\n      },\n      children() {\n        return map(child => map(fn, child), tree.children);\n      },\n    });\n  },\n});\n\nApplicative.instance(Tree, {\n  pure(value) {\n    return new Tree({\n      data() {\n        return value;\n      }\n    });\n  }\n});\n\n\nMonad.instance(Tree, {\n  flatMap(fn, tree) {\n    let next = thunk(() => fn(tree.data));\n    return new Tree({\n      data() {\n        return next().data;\n      },\n      children() {\n        return map(child => flatMap(fn, child), next().children);\n      },\n    });\n  },\n});\n","import './typeclasses';\nimport Microstate from './microstate';\n\nexport default Microstate;\nexport const { create } = Microstate;\nexport { reveal } from './utils/secret';\n\nexport { default as Microstate } from './microstate';\nexport { default as Tree } from './utils/tree';\nexport { default as analyze } from './structure';\nexport { parameterized } from './types/parameters.js';\n"],"names":["Monad","type","fn","m","flatMap","Applicative","prototype","Chain","value","defineProperty","map","valueOf","filter","thing","append","chain","thunk","evaluated","result","undefined","evaluate","call","Tree","props","data","children","Object","create","prune","tree","prefix","path","node","slice","length","graft","lensTree","get","foldl","subtree","key","set","newTree","current","child","childName","rest","lens","getPrototypeOf","getPrototypeDescriptors","Class","getOwnPropertyDescriptors","StringType","String","args","concat","apply","state","NumberType","Number","reduce","accumulator","step","BooleanType","Boolean","symbol","Symbol","getOwnPropertySymbols","keep","object","reveal","includes","TYPE_PARAMETERS","parameterized","Type","defaults","params","keys","substitutions","parameters","param","index","name","names","parameter","k","toString","join","Constructor","any","ArrayType","Array","item","splice","i","array","removed","callback","startIndex","values","Microstate","constructor","T","unchanged","added","$","moved","attach","structure","replacement","indexOf","lensPath","ObjectType","assign","toType","parameterized0","params0","isPrimitive","setTransition","mergeTransition","mergeDeepRight","transitionsFor","descriptors","transitionFns","isFunctionDescriptor","common","descriptor","isSimple","Values","holder","instance","ContainsTypes","Monoid","a","b","Function","isSugar","isPossibleSugar","desugar","c","Collapse","collapse","analyze","analyzeType","pure","Node","collapseState","truncated","truncate","stateAt","InitialType","valueAt","hasOwnProperty","shift","ShiftNode","childTypes","childrenAt","ChildType","Location","types","for","view","cachedGetters","total","invoke","localValue","localTree","transition","nextLocalValue","nextLocalTree","nextTree","nextValue","SymbolObservable","microstate","observer","next","bind","nextOnTransition","nextable","method","Functor","transitions","transitionsAt","mapped","hasChildren"],"mappings":"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"}